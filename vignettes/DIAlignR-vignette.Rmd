---
title: "Introduction to DIAlignR package for alignment of targeted proteomics runs"
author: "Shubham Gupta, Hannes Rost"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this document we are presenting workflow of DIAlignR for retention time (RT) alignment of targeted proteomics (e.g. DIA, SWATH-MS, PRM, SRM) runs. This tool works with MS2 chromatograms and provides a hybrid approach of global and local alignment to establish correspondence between peaks.

# Install DIAlignR
```{r installDIAlignR, eval=FALSE}
require(devtools)
install_github("Roestlab/DIAlignR")
```

```{r loadDIAlignR}
library(DIAlignR)
```

## Citation
Gupta S, Ahadi S, Zhou W, RÃ¶st H. "DIAlignR Provides Precise Retention Time Alignment Across Distant Runs in DIA and Targeted Proteomics." Mol Cell Proteomics. 2019 Apr;18(4):806-817. doi: https://doi.org/10.1074/mcp.TIR118.001132 

# Prepare chromatograms from Spectra
Mass-spec output file mostly contains spectra. Targeted proteomics works on identifying analytes from their chromatographic elutions. DIAlignR extends the same concept for retention-time alignment. Open-source software tools e.g. OpenSWATH can be used to extract features and extracted-ion chromatograms (XICs) from spectra file. A detailed [tutorial](http://openswath.org/en/latest/docs/openswath.html) to run OpenSWATH is availabe. In short, following command can be used:
```{bash, eval=FALSE}
./bin/OpenSwathWorkflow -in Spectra.mzML.gz -tr library.TraML -
swath_windows_file swathsWindows.txt -sort_swath_maps -tr_irt
iRTassays.TraML -out_tsv Feature.tsv -out_chrom XIC.chrom.mzML -readOptions cacheWorkingInMemory -tempDirectory temp/ -min_upper_edge_dist 1
```

Output files **Feature.tsv** and **XIC.chrom.mzML** are needed to perform hybrid alignment through DIAlignR. Some chromatograms are stored in compressed form and could be difficult to have accessed by `mzR`. In such cases `mzR` would throw an error indicating `Invalid cvParam accession "1002746"`. To avoid this issue, uncompress chromatograms using OpenMS.
```{bash, eval=FALSE}
./bin/FileConverter -in XIC.chrom.mzML -in_type 'mzML' -out XIC.chrom.mzML
```

# Load MS2 chromatograms using mzR
MS2 chromatograms can be extracted from mzML files using [mzR](https://bioconductor.org/packages/release/bioc/html/mzR.html) package. The workflow of extraction of a few chromatograms for this paper is provided below. From the FTP link provided [here](http://www.peptideatlas.org/PASS/PASS01280) download `mzML` files from these directories:   

* Spyogenes/raw/hroest_K120808_Strep10PlasmaBiolRepl2_R02_SW   
* Spyogenes/raw/hroest_K120808_Strep0PlasmaBiolRepl2_R01_SW    

Few precursor IDs and their transition IDs are tabulated in this file at the same FTP link:

* Spyogenes/assay/500Peptide4Alignment.csv    
```{r loadChroms, eval=FALSE}
library(mzR)
library(signal)
TargetPeptides <- read.table("500Peptide4Alignment.csv", sep = ",", header = T)
temp <- list.files(pattern="*.mzML", recursive = TRUE)
for(filename in temp){
  # This makes sure that order of extracted MS2 chromatograms is same for each run.
  mz <- openMSfile(filename, backend = "pwiz")
  chromHead <- chromatogramHeader(mz)
  filename <- gsub("(.*)(/hroest_)(.*)(_SW.chrom.mzML)", replacement = "\\3", filename)
  chromatogramIndices <- chromHead$chromatogramIndex[match(TargetPeptides$transition_name, chromHead$chromatogramId)]
  TargetPeptides[filename] <- chromatogramIndices
  transition_group_ids <- unique(TargetPeptides$transition_group_id)
  ChromsExtractedPerRun <- sapply(transition_group_ids, function(id){
    chromIndices <- chromatogramIndices[TargetPeptides$transition_group_id == id]
    # ChromsExtracted <- lapply(1:length(chromIndices), function(i) chromatograms(mz, chromIndices[i]))
    ChromsExtracted <- lapply(1:length(chromIndices), function(i) {
      rawChrom <- chromatograms(mz, chromIndices[i])
      rawChrom[,2] <- sgolayfilt(rawChrom[,2], p = 4, n = 9) # To smooth chromatograms, use Savitzky-Golay filter
      return(rawChrom)
    } )
    return(ChromsExtracted)
  })
  names(ChromsExtractedPerRun) <- transition_group_ids
  rm(mz)
  saveRDS(ChromsExtractedPerRun, paste0(filename, "_ChromSelected.rds"))
}
write.table(TargetPeptides, file = "TargetPeptidesWchromIndex.csv", sep = ",")

# Load chromatograms of all runs 
temp <- list.files(pattern = "*_ChromSelected.rds")
StrepChroms1 <- list()
for(i in 1:length(temp)){
  StrepChroms1[[i]] <- readRDS(temp[i])
}
temp <- sapply(temp, strsplit, split = "_ChromSelected.rds", USE.NAMES = FALSE)
names(StrepChroms1) <- temp
```


# Fit a global alignment function between runs
```{r globalFit}
run_pair <- c("run1", "run2")
loess.fit <- getLOESSfit(run_pair, peptides, oswOutStrep, 0.15)
StrepAnnot <- as.data.frame(StrepAnnot)
predict.run2 <- predict(loess.fit, data.frame(RUN1 = StrepAnnot[, run_pair[1]]))
Err <- predict.run2 - StrepAnnot[,run_pair[2]]
```


## plot fraction of aligned peptides
```{r plotGlobal, fig.width=6, fig.align='center', fig.height=6}
plotErrorCurve <- function(x, clr = "black", SameGraph = FALSE, xmax = 120, ...){
    x <- x[!is.na(x)]
    breaks = seq(0, xmax, by=0.5)
    duration.cut = cut(x, breaks, right = FALSE) 
    duration.freq = table(duration.cut)
    cumfreq0 = c(0, cumsum(duration.freq))
    if(SameGraph == TRUE){lines(breaks, cumfreq0/length(x), col = clr, ...)}
    else{plot(breaks, cumfreq0/length(x), col = clr, type = "l", ...)}
}
plotErrorCurve(abs(Err), "blue", xlab = "Retention time difference (in sec)", ylab = "Cumulative fraction of peptides")
```


# Fit a local alignment between chromatogram groups
```{r localFit, eval=TRUE}
simMeasure <- "dotProductMasked"
pair <- "run1_run2"
MappedTimeLocal <- getPepPeakCorp(StrepAnnot, pair, StrepChroms[["run1"]], StrepChroms[["run2"]], "local", oswOutStrep)
Err_local <- StrepAnnot[,"run2"] - MappedTimeLocal
```


```{r plotLocal, fig.width=6, fig.align='center', fig.height=6, fig.show='hold'}
plotErrorCurve(abs(Err_local), "darkgreen", SameGraph = FALSE, xlab = "Retention time difference (in sec)", ylab = "Cumulative fraction of peptides")
```


# Hybrid alignment of chromatograms
```{r hybridAlignParam}
samplingTime <-3.4 # In example dataset, all points are acquired at 3.4 second interval.
samples4gradient <- 100; RSEdistFactor <- 3.5; hardConstrain <- FALSE
meanRSE <- 7.4
gapQuantile <- 0.5; goFactor <- 1/8; geFactor <- 40
simMeasure <- "dotProductMasked"
pair <- "run1_run2"
```


```{r hybridAlign, eval=TRUE}
MappedTimeHybrid <- getPepPeakCorp(StrepAnnot, pair, StrepChroms[["run1"]], StrepChroms[["run2"]], "hybrid", oswOutStrep, meanRSE)
Err_hybrid <- StrepAnnot[,"run2"] - MappedTimeHybrid
```

```{r plotHybrid, fig.width=6, fig.align='center', fig.height=6}
plotErrorCurve(abs(Err_hybrid), "red", SameGraph = FALSE, xlab = "Retention time difference (in sec)", ylab = "Cumulative fraction of peptides")
```

## Visualize chromatograms, similarity matrix and alignment path
```{r VisualizeAlignment, fig.width=6, fig.align='center', fig.height=6, eval=FALSE}
library(lattice)
library(ggplot2)
library(reshape2)

plotChromatogram <- function(data, run, peptide, StrepAnnot, printTitle =TRUE){
  df <- do.call("cbind", data[[run]][[peptide]])
  df <- df[,!duplicated(colnames(df))]
  df <- melt(df, id.vars="time", value.name = "Intensity")
  g <- ggplot(df, aes(time, Intensity, col=variable)) + geom_line(show.legend = FALSE) + theme_bw()
  if(printTitle) g <- g + ggtitle(paste0(run, ", ",peptide)) + theme(plot.title = element_text(hjust = 0.5))
  g <- g + geom_vline(xintercept=StrepAnnot[peptide, run], lty="dotted", size = 0.4)
  return(g)
}

levelplot(s, axes = TRUE, xlab = "run1 index", ylab = "run2 index")
Path <- getAlignmentPath(AlignedIndices[[1]], s)
levelplot(s, axes = TRUE, xlab = "run1 index", ylab = "run2 index", main = paste0("Alignment path through the ", simMeasure, " similarity matrix\n for ", peptide)) + latticeExtra::as.layer(levelplot(Path, col.regions = c("transparent", "green"), alpha = 1, axes = FALSE))
```


# Session Info
```{r sessionInfo, eval=TRUE}
devtools::session_info()
```

<br>

## Last compilation
Last compiled at `r Sys.Date()`.
