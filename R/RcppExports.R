# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate similarity matrix for two sequences
#'
#' @author Shubham Gupta, \email{shubh.gupta@mail.utoronto.ca}
#' ORCID: 0000-0003-3500-8152
#' License: (c) Author (2019) + MIT
#' Date: 2019-03-05
#' @param seq1 (char) A single string
#' @param seq2 (char) A single string
#' @param Match (float) Score for character match
#' @param MisMatch (float) score for character mismatch
#' @return s (matrix) Numeric similarity matrix. Rows and columns expresses seq1 and seq2, respectively
#' @examples
#' # Get sequence similarity of two DNA strings
#' Match=10; MisMatch=-2
#' seq1 = "GCAT"; seq2 = "CAGTG"
#' getSeqSimMat(seq1, seq2, Match, MisMatch)
#' @export
getSeqSimMat <- function(seq1, seq2, Match, MisMatch) {
    .Call(`_DIAlignR_getSeqSimMat`, seq1, seq2, Match, MisMatch)
}

#' Calculate similarity matrix of two fragment-ion chromatogram group.
#'
#' @author Shubham Gupta, \email{shubh.gupta@mail.utoronto.ca}
#' ORCID: 0000-0003-3500-8152
#' License: (c) Author (2019) + MIT
#' Date: 2019-03-05
#' @param l1 (list) A list of vectors. Length should be same as of l2.
#' @param l2 (list) A list of vectors. Length should be same as of l1.
#' @param Normalization (char) A character string. Normalization must be selected from (L2, mean).
#' @param SimType (char) A character string. Similarity type must be selected from (dotProductMasked, dotProduct, cosineAngle, cosine2Angle, euclidianDist, covariance, correlation).
#' @return s (matrix) Numeric similarity matrix. Rows and columns expresses seq1 and seq2, respectively
#' @examples
#' # Get similarity matrix of dummy chromatograms
#' r1 <- list(c(1.0,3.0,2.0,4.0), c(0.0,0.0,0.0,1.0), c(4.0,4.0,4.0,5.0))
#' r2 <- list(c(1.4,2.0,1.5,4.0), c(0.0,0.5,0.0,0.0), c(2.0,3.0,4.0,0.9))
#' getChromSimMat(r1, r2, "L2", "dotProductMasked")
#' matrix(c(0.1251213, 0.1623915, 0.1437564, 0.2076481, 0.1863509, 0.2395940,
#' 0.2129724, 0.3128033, 0.2329386, 0.2728709, 0.2529048, 0.3460802, 0.1011619,
#' 0.2076481, 0.1544050, 0.2728709), 4, 4, byrow = F)
#'
#' getChromSimMat(r1, r2, "L2", "dotProduct")
#' matrix(c(0.1251213, 0.1623915, 0.1437564, 0.2076481, 0.1863509,
#'  0.2395940, 0.2129724, 0.3128033, 0.2329386, 0.2728709, 0.2529048,
#'   0.3460802, 0.1011619, 0.2076481, 0.1544050, 0.2728709), 4, 4, byrow = F)
#'
#' getChromSimMat(r1, r2, "L2", "cosineAngle")
#' matrix(c(0.9338568, 0.9994629, 0.9892035, 0.9859998, 0.9328152, 0.9889961,
#'  0.9828722, 0.9961742, 0.9935327, 0.9597374, 0.9945055, 0.9391117, 0.4495782,
#'  0.7609756, 0.6326436, 0.7715167), 4, 4, byrow = F)
#'
#' getChromSimMat(r1, r2, "L2", "cosine2Angle")
#' matrix(c(0.7441769, 0.9978523, 0.9570470, 0.9443912, 0.7402886, 0.9562264, 0.9320755,
#' 0.9847260, 0.9742143, 0.8421918, 0.9780822, 0.7638617, -0.5957588, 0.1581678,
#' -0.1995241, 0.1904762), 4, 4, byrow = F)
#'
#' getChromSimMat(r1, r2, "L2", "euclidianDist")
#' matrix(c(0.7387025, 0.7127694, 0.7250831, 0.6869622, 0.6984783, 0.6713737,
#' 0.6842335, 0.6413183, 0.6744739, 0.6568703, 0.6653819, 0.6296096, 0.7586910,
#' 0.6869622, 0.7179039, 0.6568703), 4, 4, byrow = F)
#'
#' getChromSimMat(r1, r2, "L2", "covariance")
#' getChromSimMat(r1, r2, "L2", "correlation")
#' @export
getChromSimMat <- function(l1, l2, Normalization, SimType, dotProdThresh = 0.96, cosAngleThresh = 0.3) {
    .Call(`_DIAlignR_getChromSimMat`, l1, l2, Normalization, SimType, dotProdThresh, cosAngleThresh)
}

#' Get a dummy S4 object of C++ class AffineAlignObj
#'
#' @author Shubham Gupta, \email{shubh.gupta@mail.utoronto.ca}
#' ORCID: 0000-0003-3500-8152
#' License: (c) Author (2019) + MIT
#' Date: 2019-03-08
#' @param ROW_SIZE (int) Number of rows of a matrix
#' @param COL_SIZE (int) Number of columns of a matrix
#' @return affineAlignObj (S4class) A S4class dummy object from C++ AffineAlignObj struct
#' @examples
#' x <- setAffineAlignObj_S4(4, 5)
#' x@signalA_len # 3
#' @export
setAffineAlignObj_S4 <- function(ROW_SIZE, COL_SIZE) {
    .Call(`_DIAlignR_setAffineAlignObj_S4`, ROW_SIZE, COL_SIZE)
}

#' Get a dummy S4 object of C++ class AlignObj
#'
#' @author Shubham Gupta, \email{shubh.gupta@mail.utoronto.ca}
#' ORCID: 0000-0003-3500-8152
#' License: (c) Author (2019) + MIT
#' Date: 2019-03-08
#' @param ROW_SIZE (int) Number of rows of a matrix
#' @param COL_SIZE (int) Number of columns of a matrix
#' @return AlignObj (S4class) A S4class dummy object from C++ AlignObj struct
#' @examples
#' x <- setAlignObj_S4(4, 5)
#' x@signalA_len # 3
#' @export
setAlignObj_S4 <- function(ROW_SIZE, COL_SIZE) {
    .Call(`_DIAlignR_setAlignObj_S4`, ROW_SIZE, COL_SIZE)
}

#' Perform non-affine global and overlap alignment on a similarity matrix
#'
#' @author Shubham Gupta, \email{shubh.gupta@mail.utoronto.ca}
#' ORCID: 0000-0003-3500-8152
#' License: (c) Author (2019) + MIT
#' Date: 2019-03-08
#' @param s (NumericMatrix) A numeric matrix with similarity values of two sequences or signals
#' @param signalA_len (int) Length of signalA or sequenceA. Expresses along the rows of s
#' @param signalB_len (int) Length of signalB or sequenceB. Expresses along the columns of s
#' @param gap (float) Penalty for introducing gaps in alignment
#' @param OverlapAlignment (bool) An input for alignment with free end-gaps. False: Global alignment, True: overlap alignment
#' @return AlignObj (S4class) An object from C++ class of AlignObj
#' @examples
#' # Get sequence similarity of two DNA strings
#' Match=10; MisMatch=-2
#' seq1 = "GCAT"; seq2 = "CAGTG"
#' s <- getSeqSimMat(seq1, seq2, Match, MisMatch)
#' obj_Global <- doAlignment_S4(s, 4, 5, 22, FALSE)
#' obj_Global@score # -2 -4 -6 4 -18
#' obj_Olap <- doAlignment_S4(s, 4, 5, 22, TRUE)
#' obj_Olap@score # 0 10 20 18 18 18
#' @export
doAlignment_S4 <- function(s, signalA_len, signalB_len, gap, OverlapAlignment) {
    .Call(`_DIAlignR_doAlignment_S4`, s, signalA_len, signalB_len, gap, OverlapAlignment)
}

#' Perform affine global and overlap alignment on a similarity matrix
#'
#' @author Shubham Gupta, \email{shubh.gupta@mail.utoronto.ca}
#' ORCID: 0000-0003-3500-8152
#' License: (c) Author (2019) + MIT
#' Date: 2019-03-08
#' @param s (NumericMatrix) A numeric matrix with similarity values of two sequences or signals
#' @param signalA_len (int) Length of signalA or sequenceA. Expresses along the rows of s
#' @param signalB_len (int) Length of signalB or sequenceB. Expresses along the columns of s
#' @param go (float) Penalty for introducing first gap in alignment
#' @param ge (float) Penalty for introducing subsequent gaps in alignment
#' @param OverlapAlignment (bool) An input for alignment with free end-gaps. False: Global alignment, True: overlap alignment
#' @return affineAlignObj (S4class) An object from C++ class of AffineAlignObj
#' @examples
#' # Get sequence similarity of two DNA strings
#' Match=10; MisMatch=-2
#' seq1 = "GCAT"; seq2 = "CAGTG"
#' s <- getSeqSimMat(seq1, seq2, Match, MisMatch)
#' objAffine_Global <- doAffineAlignment_S4(s, 4, 5, 22, 7, FALSE)
#' objAffine_Global@score # -2  -4  -6  4 -18
#' objAffine_Olap <- doAffineAlignment_S4(s, 4, 5, 22, 7, TRUE)
#' objAffine_Olap@score # 0 10 20 18 18 18
#'
#' seq1 = "CAT"; seq2 = "CAGTG"
#' s <- getSeqSimMat(seq1, seq2, Match, MisMatch)
#' objAffine_Global <- doAffineAlignment_S4(s, 3, 5, 22, 7, FALSE)
#' objAffine_Global@score # 10  20  -2  -9 -11
#' objAffine_Olap <- doAffineAlignment_S4(s, 3, 5, 22, 7, TRUE)
#' objAffine_Olap@score # 10 20 18 18 18
#' @export
doAffineAlignment_S4 <- function(s, signalA_len, signalB_len, go, ge, OverlapAlignment) {
    .Call(`_DIAlignR_doAffineAlignment_S4`, s, signalA_len, signalB_len, go, ge, OverlapAlignment)
}

#' Outputs a NumericMatrix of given row and column size.
#'
#' @author Shubham Gupta, \email{shubh.gupta@mail.utoronto.ca}
#' ORCID: 0000-0003-3500-8152
#' License: (c) Author (2019) + MIT
#' Date: 2019-03-05
#' @param initVal (char) Matrix intialization value
#' @param ROW_SIZE (int) Number of rows
#' @param COL_SIZE (int) Number of columns
#' @return s (NumericMatrix) A matrix
#' @examples
#' # Get a matrix of type NumericMatrix
#' initializeMatrix(0, ROW_SIZE = 4, COL_SIZE = 5)
#' @export
initializeMatrix <- function(initVal, ROW_SIZE, COL_SIZE) {
    .Call(`_DIAlignR_initializeMatrix`, initVal, ROW_SIZE, COL_SIZE)
}

